<!-- SPDX-License-Identifier: Apache-2.0 -->
# FPGA Support — Alveo U250 + PCIe XDMA

## Overview

Loom supports running transformed DUTs on an Alveo U250 FPGA with PCIe host
communication. A single `loom_shell` module serves as the top-level for both
simulation and FPGA — only the sub-module implementations differ (behavioral
BFMs for simulation, Xilinx IPs for FPGA).

## Architecture

```
loom_shell.sv (SINGLE top-level for both sim and FPGA)
├── IBUFDS_GTE4         (PCIe 100 MHz refclk buffer)
├── IBUFDS              (emulation refclk buffer)
├── xlnx_xdma           (SIM: socket BFM wrapper | FPGA: PCIe XDMA IP)
│   └── Produces: aclk, aresetn, AXI-Lite master, AXI4 full master
├── loom_axil_demux #(N_MASTERS=3, aclk domain)
│   ├── [0x0_0000] → xlnx_decoupler (AXI-Lite) → xlnx_cdc → loom_emu_top
│   ├── [0x4_0000] → xlnx_clk_gen AXI-Lite DRP
│   └── [0x5_0000] → shell control register (decouple pin control)
├── xlnx_decoupler      (SIM: behavioral | FPGA: DFX Decoupler IP)
│   ├── AXI-Lite interface (register access path)
│   └── AXI4 full interface (DMA path — unconnected RP side for now)
├── xlnx_cdc            (SIM: wire passthrough | FPGA: AXI Clock Converter IP)
│   └── AXI-Lite CDC: aclk ↔ emu_clk
├── xlnx_clk_gen        (SIM: behavioral clock gen | FPGA: Clocking Wizard IP)
│   └── emu_refclk → emu_clk + locked
├── reset synchronizer  (aclk domain → emu_clk domain)
└── loom_emu_top        (UNCHANGED — same module as always, on emu_clk)
```

**Sub-module implementations (same module name, different source files):**

| Module | Simulation (behavioral) | FPGA (Xilinx IP) |
|--------|------------------------|-------------------|
| `xlnx_xdma` | Wraps socket BFM, generates aclk (100MHz) | PCIe XDMA IP |
| `xlnx_clk_gen` | Generates emu_clk (100MHz), locked after 10 cycles | Clocking Wizard with DRP |
| `xlnx_cdc` | Wire passthrough (single clock domain in sim) | AXI Clock Converter IP |
| `xlnx_decoupler` | Behavioral pass/block | Xilinx DFX Decoupler IP |

## Address Map

The PCIe BAR / simulation AXI-Lite space uses a 20-bit address with 3 masters:

| Range | Target | Clock Domain |
|-------|--------|-------------|
| `0x0_0000 – 0x3_FFFF` | xlnx_decoupler → xlnx_cdc → loom_emu_top | emu_clk |
| `0x4_0000 – 0x4_FFFF` | Clock generator DRP | aclk |
| `0x5_0000 – 0x5_FFFF` | Shell control register | aclk |

Within the emu_top range (same as before):

| Range | Target |
|-------|--------|
| `0x0_0000 – 0x0_00FF` | emu_ctrl |
| `0x1_0000 – 0x1_FFFF` | dpi_regfile |
| `0x2_0000 – 0x2_FFFF` | scan_ctrl |

### Shell Control Register (0x5_0000)

| Offset | Name | Access | Description |
|--------|------|--------|-------------|
| `0x00` | DECOUPLE_CTRL | RW | Bit 0: `decouple` (1 = isolate emu_top, 0 = connected) |

The AXI4 DMA path bypasses the demux — it goes directly from XDMA AXI4
master → xlnx_decoupler AXI4 interface → (future DMA slave in emu_top).

## Decoupler

The DFX decoupler safely isolates `loom_emu_top` from AXI traffic. This is
controlled by the shell control register at `0x5_0000`.

- **Coupled** (decouple=0): Normal operation. AXI-Lite and AXI4 traffic
  passes through to `loom_emu_top`.
- **Decoupled** (decouple=1): `loom_emu_top` is isolated. Transactions to
  the emu_top address range return SLVERR. The RP side sees no activity.

Shell commands:
- `couple` — Clear decoupler, connect emu_top
- `decouple` — Assert decoupler, isolate emu_top

The `run` command automatically calls `couple` before starting emulation.

## Key Design Decisions

- **Unified shell**: Single `loom_shell` top-level for both sim and FPGA.
  Only sub-module implementations change (behavioral BFMs vs Xilinx IPs).
- **Unified demux**: `loom_axil_demux` is parameterizable with `N_MASTERS`,
  `BASE_ADDR`/`ADDR_MASK`. Used both inside `loom_emu_top` (3 masters) and
  in `loom_shell` (3 masters).
- **CDC**: Xilinx `axi_clock_converter` IP (or wire passthrough in sim)
  handles clock crossing between PCIe/aclk and emulation domains.
- **DFX Decoupler**: Safely isolates emu_top for clock reprogramming or
  partial reconfiguration.
- **No DDR4**: v1 uses register-only AXI-Lite access (AXI4 DMA path plumbed
  but RP side unconnected).
- **Polling**: v1 uses polling for DPI service (no IRQ).

## Clock Generator

The emulation clock is generated by a Xilinx `clk_wiz` IP with DRP
(Dynamic Reconfiguration Port) enabled. The host can reprogram the emulation
clock frequency at runtime by writing to the DRP registers at `0x4_0000`.

Default output frequency: 50 MHz (from 300 MHz input).
In simulation: 100 MHz (from behavioral BFM).

## Host Transport

`loomx -t xdma` uses the XDMA transport (`loom_transport_xdma.cpp`) which
accesses the FPGA via:

```
/dev/xdma0_user → pread/pwrite → AXI-Lite registers
```

The `Context`, `DpiService`, and shell are shared with simulation mode.
The shell `read`/`write` commands provide direct register access for
debugging. The `couple`/`decouple` commands control the DFX decoupler.

## Build Flow

```bash
# 1. Generate Xilinx IPs (one-time)
make -C fpga ip

# 2. Transform DUT (reuse simulation flow)
make -C tests/e2e transform

# 3. Build bitstream
make -C fpga bitstream TRANSFORMED_V=tests/e2e/build/transformed.v

# 4. Program FPGA
make -C fpga program

# 5. Run via loomx
loomx -work tests/e2e/build -t xdma -sv_lib tests/e2e/build/dpi
```

## Files

| File | Purpose |
|------|---------|
| `src/rtl/loom_shell.sv` | Unified top-level (sim + FPGA) |
| `src/rtl/loom_axil_demux.sv` | Parameterizable AXI-Lite 1:N demux |
| `src/bfm/xlnx_xdma.sv` | Behavioral XDMA (socket BFM wrapper) |
| `src/bfm/xlnx_clk_gen.sv` | Behavioral clock wizard |
| `src/bfm/xlnx_cdc.sv` | Behavioral AXI-Lite CDC (passthrough) |
| `src/bfm/xlnx_decoupler.sv` | Behavioral DFX decoupler |
| `src/bfm/xilinx_primitives.sv` | Behavioral IBUFDS/IBUFDS_GTE4 stubs |
| `src/host/loom_transport_xdma.cpp` | PCIe/XDMA transport |
| `fpga/Makefile` | Build orchestration |
| `fpga/boards/u250/` | Board settings and constraints |
| `fpga/ip/` | Xilinx IP generation scripts |
| `fpga/scripts/` | Vivado synthesis/implementation/programming |
| `tests/e2e/Makefile` | E2E test (sim: `make run`, FPGA: `make fpga-run`) |
