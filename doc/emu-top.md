<!-- SPDX-License-Identifier: Apache-2.0 -->
# Emulation Top Wrapper (emu_top)

The `emu_top` Yosys pass generates a complete emulation wrapper around a
transformed DUT, providing all the infrastructure needed for host
communication.

## Overview

After running `scan_insert` and `loom_instrument` on a design, the
`emu_top` pass creates a `loom_emu_top` module that:

1. Instantiates the transformed DUT
2. Controls DUT state via `loom_en` flip-flop enable
3. Connects DPI interfaces to a register file
4. Connects the scan chain to a scan controller
5. Provides an AXI-Lite slave interface for host access

## Pass Usage

```tcl
emu_top [options]

Options:
  -top <module>       DUT module name (required)
  -clk <signal>       Clock signal name (auto-detected from loom_tbx_clk attribute)
  -rst <signal>       Reset signal name
  -addr_width <N>     AXI-Lite address width
  -n_irq <N>          Number of IRQ outputs
```

Example pipeline (as generated by `loomc`):

```tcl
read_slang --loom design.sv -top my_module
hierarchy -check -top my_module
proc
opt
reset_extract -rst rst_ni
opt
scan_insert -map scan_map.pb
loom_instrument -header_out loom_dpi_dispatch.c
emu_top -top my_module -rst rst_ni
opt_clean
write_verilog -noattr transformed.v
```

## Generated Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│ loom_emu_top                                                      │
│                                                                   │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐        │
│  │ AXI-Lite     │────│ loom_axil_   │────│ loom_emu_    │        │
│  │ Interface    │    │ demux        │    │ ctrl         │        │
│  └──────────────┘    └──────┬───────┘    └──────────────┘        │
│                             │                    │                │
│                      ┌──────┴───────┐       loom_en              │
│                      │ loom_dpi_    │            │                │
│                      │ regfile      │            ▼                │
│                      └──────┬───────┘     (emu_running &         │
│                      ┌──────┴───────┐     (!dpi_valid|ack))      │
│                      │ loom_scan_   │            │                │
│                      │ ctrl         │            │                │
│                      └──────┬───────┘            │                │
│                             │                    │                │
│                      ┌──────┴───────┐            │                │
│                      │    DUT       │◄───────────┘                │
│                      │ (transformed)│  loom_en (FF enable)        │
│                      └──────────────┘                             │
└──────────────────────────────────────────────────────────────────┘
```

The AXI-Lite demux (`loom_axil_demux`) routes host traffic to three
sub-modules based on address:

| Range               | Target          |
| ------------------- | --------------- |
| `0x0_0000–0x0_FFFF` | loom_emu_ctrl   |
| `0x1_0000–0x1_FFFF` | loom_dpi_regfile|
| `0x2_0000–0x2_FFFF` | loom_scan_ctrl  |

## Infrastructure Modules

### loom_emu_ctrl

Controls the emulation state machine (run/stop/reset/snapshot/restore),
bridges DUT DPI calls to the regfile, and generates the `loom_en` signal.

**Register Map (offset from base 0x0000):**

| Offset | Name           | R/W | Description                                    |
| ------ | -------------- | --- | ---------------------------------------------- |
| 0x00   | EMU_STATUS     | R   | Current emulation state                        |
| 0x04   | EMU_CONTROL    | W   | Command register (Start, Stop, Step)           |
| 0x08   | EMU_CYCLE_LO   | R   | DUT cycle counter [31:0]                       |
| 0x0C   | EMU_CYCLE_HI   | R   | DUT cycle counter [63:32]                      |
| 0x10   | EMU_CLK_DIV    | W   | Clock divider (0 = full speed)                 |
| 0x14   | N_DPI_FUNCS    | R   | Number of DPI functions                        |
| 0x18   | N_MEMORIES     | R   | Number of shadow-ported memories               |
| 0x1C   | N_SCAN_CHAINS  | R   | Number of scan chains                          |
| 0x20   | TOTAL_SCAN_BITS| R   | Total scan chain length                        |
| 0x24   | MAX_ARGS       | R   | Max DPI arguments per function                 |
| 0x28   | DESIGN_ID      | R   | Design CRC32 (version check)                   |
| 0x2C   | LOOM_VERSION   | R   | Toolchain version                              |
| 0x30   | IRQ_STATUS     | R   | Aggregated IRQ status                          |
| 0x34   | IRQ_ENABLE     | W   | Aggregated IRQ enable                          |
| 0x38   | EMU_FINISH     | RW  | Finish request: [0]=req, [15:8]=exit_code      |
| 0x3C   | EMU_TIME_LO    | R   | DUT time counter [31:0]                        |
| 0x40   | EMU_TIME_HI    | R   | DUT time counter [63:32]                       |
| 0x44   | EMU_TIME_CMP_LO| RW  | Time compare [31:0] (emulation freezes at cmp) |
| 0x48   | EMU_TIME_CMP_HI| RW  | Time compare [63:32]                           |

**DPI state machine:**

```
StDpiIdle → StDpiForward → StDpiWait → StDpiComplete → StDpiIdle
```

- **StDpiForward**: Capture `func_id` and forward args to regfile
- **StDpiWait**: Wait for host to write result and set `done`
- **StDpiComplete**: Result registered; assert `dpi_ack`, release `loom_en`
  for one cycle so the DUT captures the stable registered result

The result is registered in `StDpiWait → StDpiComplete` to avoid
combinational hazards when `dpi_func_id` changes on the next DPI call.

### loom_dpi_regfile

Per-function argument and result registers for DPI calls.

**Per-function register block (64 bytes each, base at 0x10000):**

| Offset | Name        | R/W | Description                                                    |
| ------ | ----------- | --- | -------------------------------------------------------------- |
| +0x00  | STATUS      | R   | Bit 0: pending, Bit 1: done, Bit 2: error                     |
| +0x04  | CONTROL     | W   | Bit 1: set_done, Bit 2: set_error                             |
| +0x08  | ARG0–ARG7   | R/W | Arguments (captured from DUT, host-writable for output arrays) |
| +0x28  | RESULT_LO   | W   | Return value [31:0]                                            |
| +0x2C  | RESULT_HI   | W   | Return value [63:32]                                           |

Address decoding: `addr[15:6]` = function index, `addr[5:0]` = register.

### loom_scan_ctrl

Controls scan chain capture/restore operations. With the free-running
clock and FF enable override (`loom_en | loom_scan_enable`), the scan
controller asserts `scan_enable` and shifts one bit per cycle.

### loom_axil_demux

Parameterizable AXI-Lite 1:N demux with configurable `N_MASTERS`,
`BASE_ADDR`, and `ADDR_MASK`. Used both inside `loom_emu_top` (3 masters)
and in `loom_shell` (3 masters for decoupler, clock gen, shell control).

## FF Enable (loom_en)

The DUT clock runs free (ungated). State freezing is done via the
`loom_en` flip-flop enable signal:

```
loom_en = emu_running & (!dpi_valid | dpi_ack)
```

DUT FFs are frozen (loom_en=0) when:

1. Emulation is not in the Running state
2. A DPI call is pending and waiting for host response

Inside the DUT, each FF's enable is: `loom_en | loom_scan_enable`, so
scan operations always work regardless of `loom_en`.

Time-based stepping is implemented in software by setting
`time_cmp = time + N` then issuing `CMD_START`. The controller
freezes when `time >= time_cmp`.

## Ports

The generated `loom_emu_top` exposes a single AXI-Lite slave interface:

| Port       | Direction    | Description          |
| ---------- | ------------ | -------------------- |
| `clk_i`    | input        | System clock         |
| `rst_ni`   | input        | Active-low reset     |
| `s_axil_*` | input/output | AXI-Lite slave       |
| `finish_o` | output       | Finish request       |
| `irq_o`    | output       | IRQ (state change)   |
