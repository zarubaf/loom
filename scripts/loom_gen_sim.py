#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
"""
Loom Simulation Generator

Generates simulation infrastructure from DPI metadata:
- DPI host code (C functions to service DPI calls)
- Makefile for building and running simulation

Note: loom_sim_top.sv is a standalone testbench in src/test/ that
instantiates loom_emu_top (generated by emu_top pass) + the socket BFM.
It is completely DUT-independent.
"""

import argparse
import json
import os
import sys
from pathlib import Path


def generate_dpi_host_c(dpi_meta: dict, output_dir: Path, module_name: str) -> str:
    """Generate C host code for servicing DPI calls."""
    funcs = dpi_meta.get("dpi_functions", [])

    code = f'''// SPDX-License-Identifier: Apache-2.0
// Generated DPI host code for {module_name}
// This file services DPI function calls from the emulated design.

#include "libloom.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>

// DPI function IDs
'''

    for func in funcs:
        code += f'#define FUNC_{func["name"].upper()} {func["id"]}\n'

    code += f'''
// Number of DPI functions
#define N_DPI_FUNCS {len(funcs)}

// Forward declarations for user-implemented DPI functions
'''

    for func in funcs:
        ret_type = "void" if func.get("return") is None else "uint32_t"
        args_decl = ", ".join([f'uint32_t {arg["name"]}' for arg in func.get("args", [])])
        if not args_decl:
            args_decl = "void"
        code += f'{ret_type} impl_{func["name"]}({args_decl});\n'

    code += '''
// Service a single DPI call
// Returns 0 on success, non-zero on error
static int service_dpi_call(int func_id, loom_dpi_call_t *call, uint64_t *ret_val) {
    switch (func_id) {
'''

    for func in funcs:
        code += f'        case FUNC_{func["name"].upper()}: {{\n'

        # Extract arguments (prefix with arg_ to avoid shadowing)
        for i, arg in enumerate(func.get("args", [])):
            code += f'            uint32_t arg_{arg["name"]} = call->args[{i}];\n'

        # Call implementation
        if func.get("return") is None:
            impl_args = ", ".join([f'arg_{arg["name"]}' for arg in func.get("args", [])])
            code += f'            impl_{func["name"]}({impl_args});\n'
            code += '            *ret_val = 0;\n'
        else:
            impl_args = ", ".join([f'arg_{arg["name"]}' for arg in func.get("args", [])])
            code += f'            *ret_val = (uint64_t)impl_{func["name"]}({impl_args});\n'

        code += '            return 0;\n'
        code += '        }\n'

    code += '''        default:
            fprintf(stderr, "[dpi_host] Unknown function ID: %d\\n", func_id);
            return -1;
    }
}

// Main DPI service loop
int loom_dpi_service_loop(loom_ctx_t *ctx) {
    int rc;
    uint32_t pending_mask;
    loom_dpi_call_t call;
    uint64_t result;
    int calls_serviced = 0;

    printf("[dpi_host] Entering service loop (N_DPI_FUNCS=%d)\\n", N_DPI_FUNCS);

    while (1) {
        // Poll for pending DPI calls
        rc = loom_dpi_poll(ctx, &pending_mask);
        if (rc != LOOM_OK) {
            fprintf(stderr, "[dpi_host] Poll failed: %d\\n", rc);
            return rc;
        }

        if (pending_mask != 0) {
            // Service each pending call
            for (int i = 0; i < N_DPI_FUNCS; i++) {
                if (!(pending_mask & (1 << i))) continue;

                // Get call details
                rc = loom_dpi_get_call(ctx, i, &call);
                if (rc != LOOM_OK) {
                    fprintf(stderr, "[dpi_host] Failed to get call for func %d\\n", i);
                    continue;
                }

                // Service the call
                rc = service_dpi_call(i, &call, &result);
                if (rc != 0) {
                    fprintf(stderr, "[dpi_host] Error servicing func %d\\n", i);
                    loom_dpi_error(ctx, i);
                    continue;
                }

                // Complete the call with result
                rc = loom_dpi_complete(ctx, i, result);
                if (rc != LOOM_OK) {
                    fprintf(stderr, "[dpi_host] Failed to complete func %d\\n", i);
                    return rc;
                }

                calls_serviced++;
            }
        }

        // Check emulation state
        loom_state_t state;
        rc = loom_get_state(ctx, &state);
        if (rc != LOOM_OK) {
            fprintf(stderr, "[dpi_host] Failed to get state\\n");
            break;
        }

        // Exit when emulation stops or errors
        if (state == LOOM_STATE_FROZEN || state == LOOM_STATE_ERROR) {
            printf("[dpi_host] Emulation stopped (state=%d), exiting\\n", state);
            break;
        }

        // If no pending calls, we're probably done with this test
        // Check if any more activity expected
        if (pending_mask == 0 && calls_serviced > 0) {
            // Give a bit of time for more calls
            usleep(10000);
            rc = loom_dpi_poll(ctx, &pending_mask);
            if (rc == LOOM_OK && pending_mask == 0) {
                // No more calls, check state one more time
                rc = loom_get_state(ctx, &state);
                if (state == LOOM_STATE_RUNNING) {
                    // Still running but no DPI calls - probably test complete
                    printf("[dpi_host] No pending DPI calls, test appears complete\\n");
                    break;
                }
            }
        }

        usleep(1000);  // Small delay to avoid busy-waiting
    }

    printf("[dpi_host] Service loop exited (serviced %d calls)\\n", calls_serviced);
    return LOOM_OK;
}
'''

    filepath = output_dir / f"{module_name}_dpi_host.c"
    with open(filepath, 'w') as f:
        f.write(code)

    return str(filepath)


def generate_dpi_impl_template(dpi_meta: dict, output_dir: Path, module_name: str) -> str:
    """Generate a template for user to implement DPI functions."""
    funcs = dpi_meta.get("dpi_functions", [])

    code = f'''// SPDX-License-Identifier: Apache-2.0
// DPI function implementations for {module_name}
// Edit this file to implement the actual DPI function behavior.

#include <stdio.h>
#include <stdint.h>

'''

    for func in funcs:
        ret_type = "void" if func.get("return") is None else "uint32_t"
        args_decl = ", ".join([f'uint32_t {arg["name"]}' for arg in func.get("args", [])])
        if not args_decl:
            args_decl = "void"

        code += f'''// DPI function: {func["name"]}
{ret_type} impl_{func["name"]}({args_decl}) {{
'''

        # Print args for debugging
        for arg in func.get("args", []):
            code += f'    printf("[{func["name"]}] {arg["name"]} = %u\\n", {arg["name"]});\n'

        if func.get("return") is not None:
            code += '    // TODO: Implement actual function logic\n'
            code += '    return 0;  // Placeholder\n'

        code += '}\n\n'

    filepath = output_dir / f"{module_name}_dpi_impl.c"
    with open(filepath, 'w') as f:
        f.write(code)

    return str(filepath)


def generate_makefile(dpi_meta: dict, output_dir: Path, module_name: str,
                     loom_src: Path, dut_sv: str) -> str:
    """Generate Makefile for building simulation.

    The simulation uses:
    - loom_emu_top: generated by emu_top pass (contains all infrastructure + DUT)
    - loom_sim_top.sv: standalone testbench (src/test/)
    - loom_axil_socket_bfm: socket-based BFM
    """

    code = f'''# SPDX-License-Identifier: Apache-2.0
# Generated Makefile for {module_name} simulation

LOOM_SRC := {loom_src}
BFM_DIR := $(LOOM_SRC)/bfm
HOST_DIR := $(LOOM_SRC)/host
RTL_DIR := $(LOOM_SRC)/rtl
TEST_DIR := $(LOOM_SRC)/test

SOCKET_PATH := /tmp/loom_sim.sock
OBJ_DIR := obj_dir

# Use debug binary to work around Verilator v5.040 internal fault bug with DECLFILENAME
VERILATOR := VERILATOR_BIN=verilator_bin_dbg verilator
CC := gcc
CXX := g++

VERILATOR_FLAGS := \\
    --binary --timing -Wall -Wno-fatal \\
    -Wno-DECLFILENAME -Wno-UNUSEDSIGNAL -Wno-UNUSEDPARAM \\
    -Wno-WIDTHTRUNC -Wno-WIDTHEXPAND -Wno-BLKSEQ -Wno-TIMESCALEMOD \\
    --trace -CFLAGS "-g -O0" -LDFLAGS "-lpthread"

CFLAGS := -g -O0 -Wall -I$(HOST_DIR)
LDFLAGS := -lpthread

# RTL sources
# Note: loom_emu_top (generated by emu_top pass) contains all infrastructure
# The standalone loom_sim_top.sv just instantiates loom_emu_top + BFM
RTL_SRCS := \\
    $(RTL_DIR)/loom_emu_ctrl.sv \\
    $(RTL_DIR)/loom_axi_interconnect.sv \\
    $(RTL_DIR)/loom_dpi_regfile.sv \\
    $(RTL_DIR)/loom_emu_wrapper.sv \\
    $(RTL_DIR)/loom_clk_gate.sv \\
    $(BFM_DIR)/loom_axil_socket_bfm.sv \\
    {dut_sv} \\
    $(TEST_DIR)/loom_sim_top.sv

DPI_SRCS := $(BFM_DIR)/loom_sock_dpi.c

HOST_LIB_SRCS := $(HOST_DIR)/libloom.c $(HOST_DIR)/loom_transport_socket.c

# DPI implementation: use dpi_impl.c if provided, otherwise the generated template
DPI_IMPL := $(if $(wildcard dpi_impl.c),dpi_impl.c,{module_name}_dpi_impl.c)
HOST_SRCS := {module_name}_dpi_host.c $(DPI_IMPL) test_main.c

.PHONY: all clean sim host run

all: run

sim: $(OBJ_DIR)/Vloom_sim_top

$(OBJ_DIR)/Vloom_sim_top: $(RTL_SRCS) $(DPI_SRCS)
	@mkdir -p $(OBJ_DIR)
	$(VERILATOR) $(VERILATOR_FLAGS) --top-module loom_sim_top $(RTL_SRCS) $(DPI_SRCS) --Mdir $(OBJ_DIR) -o Vloom_sim_top

host: $(OBJ_DIR)/loom_host

$(OBJ_DIR)/loom_host: $(HOST_SRCS) $(HOST_LIB_SRCS)
	@mkdir -p $(OBJ_DIR)
	$(CC) $(CFLAGS) -o $@ $(HOST_SRCS) $(HOST_LIB_SRCS) $(LDFLAGS)

run: sim host
	@rm -f $(SOCKET_PATH)
	@echo "=== Starting Loom Simulation ==="
	@$(OBJ_DIR)/Vloom_sim_top &
	@SIM_PID=$$!; \\
	sleep 1; \\
	echo "=== Running Host ===" ; \\
	$(OBJ_DIR)/loom_host $(SOCKET_PATH); \\
	TEST_RC=$$?; \\
	kill $$SIM_PID 2>/dev/null || true; \\
	wait $$SIM_PID 2>/dev/null || true; \\
	rm -f $(SOCKET_PATH); \\
	exit $$TEST_RC

clean:
	rm -rf $(OBJ_DIR)
	rm -f $(SOCKET_PATH) *.vcd
'''

    filepath = output_dir / "Makefile"
    with open(filepath, 'w') as f:
        f.write(code)

    return str(filepath)


def generate_test_main(dpi_meta: dict, output_dir: Path, module_name: str) -> str:
    """Generate test_main.c that runs the host and checks results."""

    code = f'''// SPDX-License-Identifier: Apache-2.0
// Generated test harness for {module_name}

#include "libloom.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// External: DPI service loop from generated host code
extern int loom_dpi_service_loop(loom_ctx_t *ctx);

// External: Test result accessors (from dpi_impl.c)
extern int dpi_get_test_passed(void);
extern uint32_t dpi_get_test_result(void);

int main(int argc, char *argv[]) {{
    const char *socket_path = "/tmp/loom_sim.sock";
    if (argc > 1) {{
        socket_path = argv[1];
    }}

    printf("[test] Loom Test Harness for {module_name}\\n");
    printf("[test] Connecting to %s\\n", socket_path);

    // Create transport and context
    loom_transport_t *transport = loom_transport_socket_create();
    if (!transport) {{
        fprintf(stderr, "[test] Failed to create transport\\n");
        return 1;
    }}

    loom_ctx_t *ctx = loom_create(transport);
    if (!ctx) {{
        fprintf(stderr, "[test] Failed to create context\\n");
        loom_transport_socket_destroy(transport);
        return 1;
    }}

    // Connect with retry
    int rc = LOOM_ERR_NOT_CONNECTED;
    for (int i = 0; i < 50; i++) {{
        rc = loom_connect(ctx, socket_path);
        if (rc == LOOM_OK) break;
        usleep(100000);  // 100ms
    }}
    if (rc != LOOM_OK) {{
        fprintf(stderr, "[test] Failed to connect: %d\\n", rc);
        goto cleanup;
    }}
    printf("[test] Connected\\n");

    // Wait for design ready (state != 0 means ready)
    loom_state_t state;
    for (int i = 0; i < 10; i++) {{
        rc = loom_get_state(ctx, &state);
        if (rc == LOOM_OK) break;
        usleep(10000);
    }}

    // Get design info from context (populated by loom_connect)
    printf("[test] Design ID: 0x%08x, Version: 0x%08x, N_DPI_FUNCS: %u\\n",
           ctx->design_id, ctx->loom_version, ctx->n_dpi_funcs);

    // Release DUT reset and start emulation
    rc = loom_dut_reset(ctx, 0);  // Deassert reset
    if (rc != LOOM_OK) {{
        fprintf(stderr, "[test] Failed to release DUT reset\\n");
        goto cleanup;
    }}

    rc = loom_start(ctx);
    if (rc != LOOM_OK) {{
        fprintf(stderr, "[test] Failed to start\\n");
        goto cleanup;
    }}

    printf("[test] Starting DPI service loop\\n");

    // Run DPI service loop
    rc = loom_dpi_service_loop(ctx);

    // Get final cycle count
    uint64_t cycles;
    loom_get_cycle_count(ctx, &cycles);
    printf("[test] Final cycle count: %lu\\n", (unsigned long)cycles);

    // Check test result
    int test_passed = dpi_get_test_passed();
    if (test_passed < 0) {{
        fprintf(stderr, "[test] ERROR: dpi_report_result was never called!\\n");
        rc = 1;
    }} else if (test_passed == 0) {{
        fprintf(stderr, "[test] ERROR: Test reported FAILURE\\n");
        rc = 1;
    }} else {{
        printf("[test] Test reported SUCCESS\\n");
        rc = 0;
    }}

cleanup:
    loom_disconnect(ctx);
    loom_destroy(ctx);
    loom_transport_socket_destroy(transport);

    return rc;
}}
'''

    filepath = output_dir / "test_main.c"
    with open(filepath, 'w') as f:
        f.write(code)

    return str(filepath)


def main():
    parser = argparse.ArgumentParser(description="Generate Loom simulation infrastructure")
    parser.add_argument("--dpi-json", required=True, help="DPI metadata JSON file")
    parser.add_argument("--module", required=True, help="Top module name")
    parser.add_argument("--dut-sv", required=True, help="Transformed DUT SystemVerilog file")
    parser.add_argument("--loom-src", required=True, help="Path to Loom src/ directory")
    parser.add_argument("--output-dir", required=True, help="Output directory for generated files")

    args = parser.parse_args()

    # Load DPI metadata
    with open(args.dpi_json, 'r') as f:
        dpi_meta = json.load(f)

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    loom_src = Path(args.loom_src)

    print(f"Generating simulation infrastructure for {args.module}")
    print(f"  DPI functions: {len(dpi_meta.get('dpi_functions', []))}")
    print(f"  Note: loom_sim_top.sv is standalone at {loom_src}/test/loom_sim_top.sv")

    # Generate files
    # Note: loom_sim_top.sv is now a standalone file in src/test/
    # The emu_top pass generates loom_emu_top with all infrastructure
    files = []
    files.append(generate_dpi_host_c(dpi_meta, output_dir, args.module))
    files.append(generate_dpi_impl_template(dpi_meta, output_dir, args.module))
    files.append(generate_makefile(dpi_meta, output_dir, args.module, loom_src, args.dut_sv))
    files.append(generate_test_main(dpi_meta, output_dir, args.module))

    print("Generated files:")
    for f in files:
        print(f"  {f}")


if __name__ == "__main__":
    main()
