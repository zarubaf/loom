#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
"""
gen_rtl_replay.py - Generate RTL $deposit statements from scan chain capture

This script reads a scan chain mapping file (JSON) and captured scan data (hex),
then generates Verilog $deposit statements that can be used to replay the
captured state in an RTL simulation.

Usage:
    python gen_rtl_replay.py --map scan_map.json --data 0x123456 [--output replay.vh]
    python gen_rtl_replay.py --map scan_map.json --data-file capture.txt [--output replay.vh]

The output can be `$include`d in a testbench to restore state to a specific point.
"""

import argparse
import json
import sys
from typing import Dict, List, Any


def load_scan_map(map_file: str) -> Dict[str, Any]:
    """Load scan chain mapping from JSON file."""
    with open(map_file, 'r') as f:
        return json.load(f)


def parse_hex_data(data_str: str) -> int:
    """Parse hex string (with or without 0x prefix) to integer."""
    data_str = data_str.strip()
    if data_str.startswith('0x') or data_str.startswith('0X'):
        return int(data_str, 16)
    return int(data_str, 16)


def extract_bit(data: int, bit_pos: int) -> int:
    """Extract a single bit from the data."""
    return (data >> bit_pos) & 1


def generate_deposit_statements(scan_map: Dict[str, Any], captured_data: int,
                                 module_prefix: str = "") -> List[str]:
    """
    Generate $deposit statements from scan map and captured data.

    The scan chain captures bits from MSB (scan_out) to LSB:
    - captured[0] = first bit shifted out = highest chain position
    - captured[N-1] = last bit shifted out = chain position 0

    During capture, bits shift out from position chain_length-1 to 0.
    So captured[i] corresponds to chain_position = chain_length - 1 - i.
    """
    statements = []
    chain_length = scan_map['chain_length']
    flops = scan_map['flops']

    # Group flops by their original register name (excluding bit index)
    registers = {}
    for flop in flops:
        wire_name = flop['wire_name']
        bit_index = flop['bit_index']
        chain_pos = flop['chain_position']
        width = flop['width']

        if wire_name not in registers:
            registers[wire_name] = {
                'width': width,
                'bits': {}
            }

        # Map chain position to captured bit position
        # captured[0] = chain_position chain_length-1
        # captured[chain_length-1] = chain_position 0
        captured_bit_pos = chain_length - 1 - chain_pos
        bit_value = extract_bit(captured_data, captured_bit_pos)

        registers[wire_name]['bits'][bit_index] = bit_value

    # Generate deposit statements for each register
    for wire_name, reg_info in registers.items():
        width = reg_info['width']
        bits = reg_info['bits']

        # Reconstruct the full value
        value = 0
        for bit_idx in range(width):
            if bit_idx in bits:
                if bits[bit_idx]:
                    value |= (1 << bit_idx)

        # Format the wire name with optional module prefix
        full_name = f"{module_prefix}{wire_name}" if module_prefix else wire_name

        # Generate $deposit statement
        if width == 1:
            statements.append(f"$deposit({full_name}, 1'b{value});")
        else:
            statements.append(f"$deposit({full_name}, {width}'h{value:x});")

    return statements


def generate_replay_task(statements: List[str], task_name: str = "restore_state") -> str:
    """Generate a complete Verilog task with all deposit statements."""
    lines = [
        f"// Auto-generated by gen_rtl_replay.py",
        f"// Restores captured scan chain state to RTL simulation",
        f"",
        f"task {task_name};",
        f"begin"
    ]

    for stmt in statements:
        lines.append(f"    {stmt}")

    lines.extend([
        f"end",
        f"endtask",
        ""
    ])

    return '\n'.join(lines)


def generate_initial_block(statements: List[str]) -> str:
    """Generate Verilog code with deposit statements in an initial block."""
    lines = [
        "// Auto-generated by gen_rtl_replay.py",
        "// Restores captured scan chain state to RTL simulation",
        "",
        "initial begin",
        "    // Wait for reset to complete",
        "    @(negedge rst);",
        "    @(posedge clk);",
        "    ",
        "    // Deposit captured state",
    ]

    for stmt in statements:
        lines.append(f"    {stmt}")

    lines.extend([
        "end",
        ""
    ])

    return '\n'.join(lines)


def main():
    parser = argparse.ArgumentParser(
        description='Generate RTL $deposit statements from scan chain capture'
    )
    parser.add_argument('--map', required=True,
                        help='Scan chain mapping JSON file')
    parser.add_argument('--data',
                        help='Captured data as hex string (e.g., 0x123456)')
    parser.add_argument('--data-file',
                        help='File containing captured data as hex string')
    parser.add_argument('--output', '-o',
                        help='Output file (default: stdout)')
    parser.add_argument('--prefix', default='',
                        help='Module prefix for hierarchical names (e.g., "dut.")')
    parser.add_argument('--format', choices=['task', 'initial', 'statements'],
                        default='task',
                        help='Output format (default: task)')
    parser.add_argument('--task-name', default='restore_state',
                        help='Task name for task format (default: restore_state)')

    args = parser.parse_args()

    # Load scan map
    try:
        scan_map = load_scan_map(args.map)
    except Exception as e:
        print(f"Error loading scan map: {e}", file=sys.stderr)
        sys.exit(1)

    # Get captured data
    if args.data:
        data_str = args.data
    elif args.data_file:
        with open(args.data_file, 'r') as f:
            data_str = f.read().strip()
    else:
        print("Error: must specify --data or --data-file", file=sys.stderr)
        sys.exit(1)

    try:
        captured_data = parse_hex_data(data_str)
    except Exception as e:
        print(f"Error parsing captured data: {e}", file=sys.stderr)
        sys.exit(1)

    # Generate deposit statements
    statements = generate_deposit_statements(scan_map, captured_data, args.prefix)

    # Format output
    if args.format == 'task':
        output = generate_replay_task(statements, args.task_name)
    elif args.format == 'initial':
        output = generate_initial_block(statements)
    else:  # statements
        output = '\n'.join(statements) + '\n'

    # Write output
    if args.output:
        with open(args.output, 'w') as f:
            f.write(output)
        print(f"Wrote {len(statements)} $deposit statements to {args.output}")
    else:
        print(output)


if __name__ == '__main__':
    main()
