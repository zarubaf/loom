# SPDX-License-Identifier: Apache-2.0
# gen_equiv.tcl — Generic FSM-extraction equivalence-test generator
#
# Usage:  yosys -m slang.so -p "tcl gen_equiv.tcl <module_name>"
#
# Inputs:  <module_name>.sv
# Outputs: transformed_<module_name>.v     (Loom-transformed synthesizable Verilog)
#          tb_<module_name>_equiv.sv        (auto-generated equivalence testbench)

set mod [lindex $argv 0]
if {$mod eq ""} {
    puts "Usage: yosys -m slang.so -p \"tcl gen_equiv.tcl <module_name>\""
    error "missing module name"
}

set src    "${mod}.sv"
set json   "_ports.json"
set vout   "transformed_${mod}.v"
set tbout  "tb_${mod}_equiv.sv"

# --- Step 1: Read + elaborate + optimise ---
yosys "read_slang --loom $src"
yosys "hierarchy -check -top $mod"
yosys "proc"
yosys "opt"

# --- Step 2: Export port metadata (before rename) ---
yosys "write_json $json"

# --- Step 3: Finish transform + write synthesizable Verilog ---
yosys "pmuxtree"
yosys "opt_clean"
yosys "rename $mod ${mod}_dut"
yosys "write_verilog -noattr $vout"

# --- Step 4: Parse ports from JSON ---
#
# Extracts {name direction width} triples from the Yosys JSON "ports" section.
# Only needs the top-level module — no full JSON parser required.
proc parse_ports {json_file} {
    set f [open $json_file r]
    set content [read $f]
    close $f

    set ports [list]
    set state "seek_ports"
    set cur_port ""
    set cur_dir ""
    set cur_bits 0

    foreach line [split $content "\n"] {
        set trimmed [string trim $line]

        switch $state {
            seek_ports {
                if {[regexp {"ports"\s*:\s*\{} $trimmed]} {
                    set state "in_ports"
                }
            }
            in_ports {
                if {[regexp {^"(\w+)"\s*:\s*\{} $trimmed -> name]} {
                    set cur_port $name
                    set cur_dir ""
                    set cur_bits 0
                    set state "in_port"
                } elseif {[regexp {^\}} $trimmed]} {
                    break
                }
            }
            in_port {
                if {[regexp {"direction"\s*:\s*"(\w+)"} $trimmed -> dir]} {
                    set cur_dir $dir
                } elseif {[regexp {"bits"\s*:\s*\[(.+)\]} $trimmed -> bits_str]} {
                    set cur_bits [llength [split $bits_str ","]]
                } elseif {[regexp {^\}} $trimmed]} {
                    lappend ports [list $cur_port $cur_dir $cur_bits]
                    set state "in_ports"
                }
            }
        }
    }

    return $ports
}

set ports [parse_ports $json]

# --- Classify ports ---
set clk_port ""
set inputs  [list]
set outputs [list]

foreach p $ports {
    lassign $p name dir width
    if {$dir eq "input" && $width == 1 && [string match "*clk*" $name]} {
        set clk_port $name
    } elseif {$dir eq "input"} {
        lappend inputs [list $name $width]
    } else {
        lappend outputs [list $name $width]
    }
}

if {$clk_port eq ""} {
    error "no clock port found (expected: input, 1-bit, name contains 'clk')"
}

# --- Step 5: Generate equivalence testbench ---
proc build_port_connections {clk_port inputs outputs suffix} {
    set lines [list]
    lappend lines "        .${clk_port}(${clk_port})"
    foreach inp $inputs {
        lassign $inp name width
        lappend lines "        .${name}(${name})"
    }
    foreach outp $outputs {
        lassign $outp name width
        lappend lines "        .${name}(${name}${suffix})"
    }
    return [join $lines ",\n"]
}

set tb {}
append tb "// SPDX-License-Identifier: Apache-2.0\n"
append tb "// Auto-generated equivalence testbench for $mod\n"
append tb "// Generated by gen_equiv.tcl -- DO NOT EDIT\n"
append tb "module tb_${mod}_equiv;\n"
append tb "\n"
append tb "    logic $clk_port = 0;\n"
append tb "    always #1 $clk_port = ~$clk_port;\n"
append tb "\n"

# Declare input stimulus signals
foreach inp $inputs {
    lassign $inp name width
    if {$width > 1} {
        append tb "    logic \[[expr {$width - 1}]:0\] $name;\n"
    } else {
        append tb "    logic $name;\n"
    }
}

# Declare output wires (_dut / _ref)
foreach outp $outputs {
    lassign $outp name width
    if {$width > 1} {
        append tb "    logic \[[expr {$width - 1}]:0\] ${name}_dut, ${name}_ref;\n"
    } else {
        append tb "    logic ${name}_dut, ${name}_ref;\n"
    }
}
append tb "\n"

# DUT instance (transformed)
append tb "    ${mod}_dut u_dut (\n"
append tb [build_port_connections $clk_port $inputs $outputs "_dut"]
append tb "\n    );\n\n"

# Reference instance (original behavioral)
append tb "    $mod u_ref (\n"
append tb [build_port_connections $clk_port $inputs $outputs "_ref"]
append tb "\n    );\n\n"

# Error counter + stimulus + checking
append tb "    int errors = 0;\n"
append tb "\n"
append tb "    initial begin\n"

# Initialize inputs to zero
foreach inp $inputs {
    lassign $inp name width
    append tb "        $name = 0;\n"
}
append tb "\n"
append tb "        for (int i = 0; i < 1000; i++) begin\n"

# Randomize all non-clock inputs
# Randomize all non-clock inputs (including zero for multi-bit inputs)
foreach inp $inputs {
    lassign $inp name width
    append tb "            $name = \$urandom;\n"
}
append tb "\n"
append tb "            @(posedge $clk_port);\n"
append tb "\n"
append tb "            if (i > 2) begin\n"

# Check each output
foreach outp $outputs {
    lassign $outp name width
    append tb "                if (${name}_dut !== ${name}_ref) begin\n"
    append tb "                    if (errors < 20)\n"
    append tb "                        \$display(\"MISMATCH cycle %0d: $name  dut=%0d ref=%0d\",\n"
    append tb "                                 i, ${name}_dut, ${name}_ref);\n"
    append tb "                    errors++;\n"
    append tb "                end\n"
}

append tb "            end\n"
append tb "        end\n"
append tb "\n"
append tb "        if (errors == 0)\n"
append tb "            \$display(\"PASS: $mod 1000 cycles, outputs match.\");\n"
append tb "        else begin\n"
append tb "            \$display(\"FAIL: $mod %0d mismatches in 1000 cycles.\", errors);\n"
append tb "            \$fatal;\n"
append tb "        end\n"
append tb "\n"
append tb "        \$finish;\n"
append tb "    end\n"
append tb "\n"
append tb "endmodule\n"

# Write testbench file
set f [open $tbout w]
puts -nonewline $f $tb
close $f

# Clean up temporary JSON
file delete $json

yosys "log Generated: $vout, $tbout"
