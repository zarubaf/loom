
 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2026  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.62 (git sha1 7326bb7d6, c++ 17.0.0 -fPIC -O3)

-- Executing script file `transform_counter.ys' --

1. Executing SLANG frontend.
Top level design units:
    multi_counter

Build succeeded: 0 errors, 0 warnings

1.1. Executing UNDRIVEN pass. (resolve undriven signals)

1.2. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\multi_counter.$9'.
Found and cleaned up 1 empty switch in `\multi_counter.$0'.
Cleaned up 2 empty switches.

1.3. Executing TRIBUF pass.

1.4. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 3 switch rules as full_case in process $9 in module multi_counter.
Marked 3 switch rules as full_case in process $0 in module multi_counter.
Removed a total of 0 dead cases.

1.5. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 4 redundant assignments.
Promoted 0 assignments to connections.

1.6. Executing PROC_INIT pass (extract init attributes).

1.7. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~10 debug messages>

1.8. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\multi_counter.$9'.
     1/5: $counter_b.wrapped$12
     2/5: $counter_b.wrapped$15
     3/5: $counter_b.counter$14
     4/5: $counter_b.wrapped$17
     5/5: $counter_b.counter$16
Creating decoders for process `\multi_counter.$0'.
     1/5: $counter_a.wrapped$3
     2/5: $counter_a.wrapped$6
     3/5: $counter_a.counter$5
     4/5: $counter_a.wrapped$8
     5/5: $counter_a.counter$7

1.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 5 empty switches in `\multi_counter.$9'.
Removing empty process `multi_counter.$9'.
Found and cleaned up 5 empty switches in `\multi_counter.$0'.
Removing empty process `multi_counter.$0'.
Cleaned up 10 empty switches.

1.10. Executing OPT_EXPR pass (perform const folding).
Optimizing module multi_counter.

2. Executing HIERARCHY pass (managing design hierarchy).

2.1. Analyzing design hierarchy..
Top module:  \multi_counter

2.2. Analyzing design hierarchy..
Top module:  \multi_counter
Removed 0 unused modules.

3. Printing statistics.

=== multi_counter ===

        +----------Local Count, excluding submodules.
        | 
       84 wires
      388 wire bits
       32 public wires
      164 public wire bits
       12 ports
       56 port bits
       30 cells
        2   $add
        6   $aldff
        2   $eq
        2   $logic_not
       18   $mux

4. Executing PROC pass (convert processes to netlists).

4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

4.4. Executing PROC_INIT pass (extract init attributes).

4.5. Executing PROC_ARST pass (detect async resets in processes).

4.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

4.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

4.8. Executing PROC_DLATCH pass (convert process syncs to latches).

4.9. Executing PROC_DFF pass (convert process syncs to FFs).

4.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

4.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

4.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module multi_counter.

5. Executing SCAN_INSERT pass.
Processing module multi_counter
  Found 6 flip-flop(s)
  Processing $driver$counter_b.wrapped (width=1)
  Processing $driver$counter_b.prev_counter (width=16)
  Processing $driver$counter_b.counter (width=16)
  Processing $driver$counter_a.wrapped (width=1)
  Processing $driver$counter_a.prev_counter (width=8)
  Processing $driver$counter_a.counter (width=8)
  Inserted scan chain with 6 element(s), 50 bits total
  Added ports: loom_scan_enable (in), loom_scan_in (in), loom_scan_out (out)
Wrote scan chain mapping to 'scan_map_counter.json' (50 bits)

6. Executing EMU_TOP pass.
Creating wrapper 'emu_top_multi_counter' for DUT 'multi_counter'
  Clock signal: clk
  Reset signal: rst
  No DPI interface detected in DUT
  Scan interface detected:
    loom_scan_enable: input (1 bit)
    loom_scan_in:     input (1 bit)
    loom_scan_out:    output (1 bit)
Generated wrapper module 'emu_top_multi_counter'
  Instantiated: loom_clk_gate (u_clk_gate)
  Instantiated: multi_counter (u_dut)
  Clock gating: disabled (no DPI)

7. Executing OPT pass (performing simple optimizations).

7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module emu_top_multi_counter.
Optimizing module multi_counter.

7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\emu_top_multi_counter'.
Computing hashes of 2 cells of `\emu_top_multi_counter'.
Finding duplicate cells in `\emu_top_multi_counter'.
Finding identical cells in module `\multi_counter'.
Computing hashes of 36 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
Computing hashes of 35 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
<suppressed ~3 debug messages>
Removed a total of 1 cells.

7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \emu_top_multi_counter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \multi_counter..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$45.
    dead port 1/2 on $mux $procmux$39.
    dead port 1/2 on $mux $procmux$33.
    dead port 2/2 on $mux $procmux$30.
    dead port 1/2 on $mux $procmux$18.
    dead port 1/2 on $mux $procmux$12.
    dead port 1/2 on $mux $procmux$6.
    dead port 2/2 on $mux $procmux$3.
Removed 8 multiplexer ports.
<suppressed ~30 debug messages>

7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \emu_top_multi_counter.
  Optimizing cells in module \multi_counter.
Performed a total of 0 changes.

7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\emu_top_multi_counter'.
Computing hashes of 2 cells of `\emu_top_multi_counter'.
Finding duplicate cells in `\emu_top_multi_counter'.
Finding identical cells in module `\multi_counter'.
Computing hashes of 27 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
Removed a total of 0 cells.

7.6. Executing OPT_DFF pass (perform DFF optimizations).
Changing const-value async load to async reset on $driver$counter_a.counter ($aldff) from module multi_counter.
Adding EN signal on $driver$counter_a.counter ($aldff) from module multi_counter (D = $auto$scan_insert.cc:192:run_scan_insert$65, Q = \counter_a.counter).
Changing const-value async load to async reset on $driver$counter_a.prev_counter ($aldff) from module multi_counter.
Changing const-value async load to async reset on $driver$counter_a.wrapped ($aldff) from module multi_counter.
Adding EN signal on $driver$counter_a.wrapped ($aldff) from module multi_counter (D = $auto$scan_insert.cc:192:run_scan_insert$61, Q = \counter_a.wrapped).
Changing const-value async load to async reset on $driver$counter_b.counter ($aldff) from module multi_counter.
Adding EN signal on $driver$counter_b.counter ($aldff) from module multi_counter (D = $auto$scan_insert.cc:192:run_scan_insert$59, Q = \counter_b.counter).
Changing const-value async load to async reset on $driver$counter_b.prev_counter ($aldff) from module multi_counter.
Changing const-value async load to async reset on $driver$counter_b.wrapped ($aldff) from module multi_counter.
Adding EN signal on $driver$counter_b.wrapped ($aldff) from module multi_counter (D = $auto$scan_insert.cc:192:run_scan_insert$55, Q = \counter_b.wrapped).

7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \emu_top_multi_counter..
Finding unused cells or wires in module \multi_counter..
Removed 1 unused cells and 38 unused wires.
<suppressed ~2 debug messages>

7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module emu_top_multi_counter.
Optimizing module multi_counter.
<suppressed ~6 debug messages>

7.9. Rerunning OPT passes. (Maybe there is more to do..)

7.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \emu_top_multi_counter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \multi_counter..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

7.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \emu_top_multi_counter.
  Optimizing cells in module \multi_counter.
Performed a total of 0 changes.

7.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\emu_top_multi_counter'.
Computing hashes of 2 cells of `\emu_top_multi_counter'.
Finding duplicate cells in `\emu_top_multi_counter'.
Finding identical cells in module `\multi_counter'.
Computing hashes of 34 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
Computing hashes of 32 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

7.13. Executing OPT_DFF pass (perform DFF optimizations).

7.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \emu_top_multi_counter..
Finding unused cells or wires in module \multi_counter..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

7.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module emu_top_multi_counter.
Optimizing module multi_counter.

7.16. Rerunning OPT passes. (Maybe there is more to do..)

7.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \emu_top_multi_counter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \multi_counter..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~22 debug messages>

7.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \emu_top_multi_counter.
  Optimizing cells in module \multi_counter.
Performed a total of 0 changes.

7.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\emu_top_multi_counter'.
Computing hashes of 2 cells of `\emu_top_multi_counter'.
Finding duplicate cells in `\emu_top_multi_counter'.
Finding identical cells in module `\multi_counter'.
Computing hashes of 32 cells of `\multi_counter'.
Finding duplicate cells in `\multi_counter'.
Removed a total of 0 cells.

7.20. Executing OPT_DFF pass (perform DFF optimizations).

7.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \emu_top_multi_counter..
Finding unused cells or wires in module \multi_counter..

7.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module emu_top_multi_counter.
Optimizing module multi_counter.

7.23. Finished fast OPT passes. (There is nothing left to do.)

8. Executing Verilog backend.

8.1. Executing BMUXMAP pass.

8.2. Executing DEMUXMAP pass.
Dumping module `\emu_top_multi_counter'.
Dumping module `\multi_counter'.

9. Printing statistics.

=== emu_top_multi_counter ===

        +----------Local Count, excluding submodules.
        | 
       17 wires
       61 wire bits
       17 public wires
       61 public wire bits
       15 ports
       59 port bits
        1 cells
        1   loom_clk_gate
        1 submodules
        1   multi_counter

=== multi_counter ===

        +----------Local Count, excluding submodules.
        | 
       61 wires
      343 wire bits
       35 public wires
      167 public wire bits
       15 ports
       59 port bits
       32 cells
        2   $add
        2   $adff
        4   $adffe
        2   $eq
       16   $mux
        2   $reduce_and
        4   $reduce_bool

=== design hierarchy ===

        +----------Count including submodules.
        | 
       32 multi_counter

        +----------Count including submodules.
        | 
       61 wires
      343 wire bits
       35 public wires
      167 public wire bits
       15 ports
       59 port bits
        - memories
        - memory bits
        - processes
       32 cells
        2   $add
        2   $adff
        4   $adffe
        2   $eq
       16   $mux
        2   $reduce_and
        4   $reduce_bool

End of script. Logfile hash: 26929f311c, CPU: user 0.01s system 0.01s, MEM: 20.36 MB peak
Yosys 0.62 (git sha1 7326bb7d6, c++ 17.0.0 -fPIC -O3)
Time spent: 32% 6x opt_expr (0 sec), 13% 3x opt_clean (0 sec), ...
